1. A subquery is a query inside of a query. 

2. You can use them in two places, inside the SELECT clause or inside the WHERE clause. 

3. You employ subqueries when you want to apply a function that will only apply to a specific query and not the whole. 

4. A row constructor is a way to find display information from a query in a way of your choosing. You can design the row to display the information, if found, that you declare specifically. 

5. If any information inside the row constructor returns NULL the entire thing will return NULL. 

6. Row constructor, EXISTS, NOT EXISTS, IN , NOT IN, ALL, ANY, SOME

-------------------------------------------------------------------------------------------------------------

7. EMPLOYEES 

   CREATE TABLE employees (
    empId int,
    name text, 
    shiftId int
    );
    
    INSERT INTO employees (empId, name, shiftId)
    VALUES 
    (1, 'Jimmy', 1),
    (2, 'Alana', 1),
    (3, 'Nene', 2),
    (4, 'Jana', 3),
    (5, 'Adam', 3),
    (6, 'Tom', 4),
    (7, 'Drew', 4),
    (8, 'Cisco', 5),
    (9, 'Sean', 5),
    (10, 'Austin', 6),
    (11, 'Kim' 6);
    
    CREATE TABLE shifts (
     shiftId int,
     time varchar(20)
    );
    
    INSERT INTO shifts (shiftId, time)
    VALUES
    (1, '7a-3p'),
    (2, '9a-5p'),
    (3, '11a-7p'),
    (4, '3p-11p'),
    (5, '7p-3a'),
    (6, '11p-7a');
    
 * SELECT employees.name, employees.shiftId
   FROM employees, shifts
   WHERE employees.shiftId = shifts.shiftId
   
*  SELECT employees.name, shifts.shiftId
   FROM employees, shifts
   WHERE employees.shiftId IN
   (SELECT shifts.shiftId
    FROM shifts
    WHERE shifts.shiftId = employees.shiftId);
   
-------------------------------------------------------------------------------------------------------------   
8. DOGS: id, name, gender, age, weight, intake_date, breed, in_foster
   CATS: id, name, gender, age, intake_date, adoption_date
   ADOPTIONS: id, adopter, cat, dog, fee, date
   ADOPTERS: first_name, last_name, address, phone
   VOLUNTEERS: id, name, address, phone_number, available_to_foster, foster_id
   
  *SELECT volunteers.name, dogs.name
   FROM volunteers, dogs
   WHERE adoptions.id IN
    (SELECT adoptions.id
     FROM adoptions
     WHERE adoptions.id = volunteers.id
     AND adoptions.dog = dogs.id)
   AND volunteers.name = volunteers.name
   ORDER BY dogs.name;
     
  *SELECT adopters.first_name, adopters.last_name, dogs.name
   FROM adopters, dogs
   WHERE adoptions.date IN
    (SELECT adoptions.date
      FROM adoptions
      WHERE adoptions.date < '2017/3/10')
   AND adopters.first_name = adoptions.adopter;
     
  
  *SELECT adopters.first_name, adopters.last_name, dogs.name
   FROM adopters, dogs 
   WHERE adoptions.adopter NOT IN 
    (SELECT adoptions.adopter
     FROM adoptions
     WHERE adoptions.adopter = adopters.first_name)
   AND dogs.id = dogs.id;
    
   
  *SELECT dogs.name, cats.name
   FROM dogs, cats
   WHERE dogs.in_foster = NULL
   AND cats.adoption_date = NULL
   
   
  *SELECT volunteers.name, dogs.name
   FROM volunteers v, dogs 
   WHERE dogs.name IN 
   (SELECT dogs.name
    FROM dogs
    WHERE in_foster = NULL)
   AND 
    (SELECT volunteers.name, dogs.name
     FROM volunteers v, dogs
     WHERE dogs.in_foster = TRUE
     AND v.name = adopters.first_name
     AND adoptions.dog = dogs.name)
   AND v.available_to_foster = TRUE;

9. SELECT adoptions.cat
   FROM adoptions 
   WHERE cats.id IN
    (SELECT cats.id
     FROM cats
     WHERE adoptions.cat = cat.id
     AND cat.name = 'Seashell);
   
-------------------------------------------------------------------------------------------------------------

BOOKS: isbn, title, author
TRANSACTIONS: id, checked_out_date, checked_in_date, user_id, isbn
HOLDS: id, isbn, user_id, rank, date
PATRONS: id, name, fine_amount


*SELECT holds.rank, patrons.name
 FROM holds h, patrons p
 WHERE books.title IN
  (SELECT books.title
   FROM books
   WHERE title = 'Harry Potter and the Sorcererâ€™s Stone')
 ORDER BY holds.rank;
 
 
 *SELECT books.title
  FROM books
  WHERE check_in_date IN
   (SELECT check_in_date as checkedout
    FROM transactions t
    WHERE check_in_date < '2017/3/10');
    
 *SELECT SUM(checked_in_date - checked_out_date) as time, books.title
  FROM transactions t, books
  WHERE t.checked_in_date > '2017/2/09'
  ORDER BY time;
  
  
 *SELECT books.title
  FROM books
  WHERE checked_out_date IN
   (SELECT checked_out_date
    FROM transactions
    WHERE checked_out_date > 2012/3/10);
    
 *SELECT patrons.name, books.title
  FROM patrons p, books b
  WHERE tranasactions.user_id IN 
   (SELECT transactions.user_id
    FROM transactions t
    WHERE t.user_id = patrons.id
    AND t.checked_in_date = NULL);
-------------------------------------------------------------------------------------------------------------

AIRPLANES: model, seat_capacity, range
FLIGHTS: flight_number, destination, origin, company, distance, flight_time, airplane_model
TRANSACTIONS: id, seats_sold, total_revenue, total_cost, flight_number, date

*SELECT model
 FROM airplanes
 WHERE airplane_model IN 
  (SELECT airplane_model
  FROM flights f, transactions t
  WHERE f.flight_number = t.flight_number
  AND t.seats_sold > 100
  AND date > 2017/2/09);
  
*SELECT destination, origin
 FROM flights
 WHERE destination = destination
 AND origin = origin
  (SELECT SUM(seats_sold) FROM transactions / SUM(seat_capacity) FROM airplanes * 100 as result
   WHERE result >= 90);
  
*SELECT SUM(total_revenue) 
 FROM transactions
 WHERE EXISTS
  (SELECT origin, destination
   FROM flights
   WHERE origin = 'Atlanta'
   OR destination = 'Atlanta');
   
   
12. For me joins are easier to understand, I can visualize what the tables are doing on a join. The subqueries are very logical, however it requires more thought to figure out what exactly is going on. 